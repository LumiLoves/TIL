#### 0331
* 캐시에 대해 자세히 알 필요가 생겨서 찾아보는 중...
  * location.href = url vs location.replace(url)
  * redirect
  * 301 moved permanently
  * 리소스 별 캐시정책 및 nginx 설정
![리소스별 캐시설정](https://user-images.githubusercontent.com/23192677/55290593-0b75f300-5410-11e9-9111-5f58290c5b85.png)
  * [참고]
    * https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=ko

#### 0405
* nuxt로 prop을 넘기는 이슈
  * layout 폴더 내의 뷰 컴포넌트에서 사용하는 page 컴포넌트를 가리키는 <nuxt />에는 props로 데이터가 전달되지 않는군..?! 삽질삽질ㅜ.
  * 구글링해봐도 store를 쓰는 방법 밖에 없다는 대답이 많은데 이유가 뭘까?
  * `생각한 것`: 아마도 nuxt가 제어하는 규칙내에서 동작하기 위해서, layout 컴포넌트들과 page 컴포넌트들이 바로 위/아래 뎁스로 연결된 것이 아니라 중간에 감춰진 컴포넌트가 껴있기 때문에 거기서 온전히 props로 전달을 안하고 있기 때문이 아닐까..?! 생각해봤다. 좀 더 알게 되면 기록을 남기는 것으로.!
* 비디오 백그라운드와 CSS 백그라운드 이슈
  * GPU가 색상에 미치는 영향을 파악해야 함?!
  * https://stackoverflow.com/questions/35214962/html5-video-background-color-not-matching-background-color-of-website-in-some

#### 0417
* 이슈
  * 크롬에서 `<video> 소리 킨 상태 + 자동재생 불가` 한 이슈 발생
  * 브라우저 정책상 막혀 있다는 것을 알았는데, 문제는 자동재생+소리가 나오는 비디오를 재생해야 함.
  * 기획자와 조율해보기 전에 해결가능한 방법이 있는지 검색해 보고, 팀원들에게 의견도 받아 봄
* 해결/협업한 방법
  * 기획&디자인 담당자분께 상황(구글 정책)을 설명하고, 요구사항을 조율 => 무음+자동재생 중 사용자가 직접 '클릭'액션을 해줄 때 소리를 켜도록 함
  * 이렇게 한 이유는, 의견 중 브라우저에서 정책적으로 막힌 것을 어떤 트릭을 써서 되게하더라도 다시 막힐 가능성이 있기 때문에
  * 앞으로도 비슷한 결의 이슈(정책적으로 막힌 기술)가 발생할 때는, 구현을 우선으로 두기보다 빨리 현상을 공유하고 조율할 수 있도록 커뮤니케이션하는게 우선이 되도록 해야겠음
* [참고]
  * [Autoplay Policy Changes - Google developers](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes)
  * [html5 video 태그 자동재생 이슈 – Hoon CHOI – Medium](https://medium.com/@idchoi2/html5-video-%ED%83%9C%EA%B7%B8-%EC%9E%90%EB%8F%99%EC%9E%AC%EC%83%9D-%EC%9D%B4%EC%8A%88-f97e5d397516)


#### 0729월
* 오늘 사내에서 외부초빙특강을 준비해주셔서 `함수형 프로그래밍`에 대해 들을 수 있었다.
* 가장 재밌고 유익하게(약간 감동?!까지도) 느껴졌던 지점은,
  * 검색해서 찾을 수 있는 이야기들을 '듣기좋게 전파'만 한 것이 아니라 
  * -> `기존에 알고있던 것을 새로운 관점으로` 바라볼 수 있도록, 교육시간동안 꾸준히 안내해줬다는 것이다.
  * 프론트엔드로만 개발을 해봤고 경험도 아직 많지 않아서인지, 이런 식의 다른 패러다임을 간접경험해보는 것이 넘 신기하고 재미졌다. 
  * (사실 강의초반엔 의도를 파악하지 못해서 어따써먹지?만 생각하느라 지루했다가.. 다행히 뒤로 갈수록 재미짐)
* `주요 키워드`는 이 정도..?
  * LISP
  * 메타프로그래밍
  * ES6의 Iterable, Generator, Promise, Monad
* 복습은 자료 받으면 다시 해봐야겠고, 오늘은 `인상깊었던 지점`만 간단히 정리하고 집에 가쟝~
  * iterable은 순회할 수 있도로 추상화되어 있음. 많은 자바스크립트 문법들이 iterable과 대응하고 있음. 언어의 프로토콜. 언어가 개발자와 소통하겠다. 메타프로그래밍을 추상화.
  * 여기에 제너레이터를 합쳐서 여러가지 명령어를 만듦 (map, filter, take, takeUntil, reduce ..)
    * 평가가 지연된 상태를 구현 가능. 성능 향상 (필요한 부분까지만 동작하고 버림)
  * map, filter 이런 것 자체가 언어. 우리가 기존에 for, if 이런식으로 언어를 배우는 방식처럼, map, filter 같은 것으로 추상화되어있는 것.
    * LISP: map, filter 이런 것으로만 코드를 작성하는 패러다임 (제대로 알아들은건가? 무튼 굉장히 신기했음)
    * 기존 명령형의 코드들을 이런 이터러블 프로그래밍으로 모두 대체할 수 있음.
  * 명령형으로 작성하는 코드는 점진적으로 작성하고, 중간중간 로그를 찍어 확인하며 개발.
    * 이때 일어나는 일들: 자료구조를 고민, 시간복잡도 줄이기, 순회하며 변수상태를 변경, 최종적으로 어떤 곳에 이펙트를 줌
    * TDD를 해도, 좋은 설계 패턴을 적용해도 우리의 에러는 항상 객체의 상태가 달라지거나, 단순한 연산을 하는 곳에서 (신입과 같은 곳에서) 남
  * reduce는 '축약' 하는 함수
  * 함수르 다루는 함수 go, pipe
  * 메타 프로그래밍을 가능하게 하는 도구들 => 클로저, 1급함수 + 더 쉽게 함수형을 도와주는 도구(이터러블, 제너레이터(코드를 값으로 다룰 수 있게함) => 기존 자바스크립트에서 할 수 없던 것들. 이것들이 언어자체에서 지원)
  * curry를 쓰면 좀 더 우아하게 '언어에 없는 것'을 추가해 쓸 수 있게 됨. (?! 이부분 좀 더 이해필요)
  * 클래스는 상속으로 조합을 하지만, 함수형은 함수와 함수의 조합을 이용해 만듦.
  * 요즘 추세는 모든 언어에서 함수형 프로그래밍을 쓸 수 있게 하는 것. 언어에 제약적인 기술이 아닌, 함수형 프로그래밍 그 자체. 어느 언어에서나 쓸 수 있게.
  * Promise는 callback지옥을 피하기 위해서만 쓴다? -> 이것은 아주 일부의 이야기
    * 비동기적인 상황의 결과를 값으로 싸서, 만들어 반환해주기 위해 존재. 내가 원하는 시점에서 평가할 수 있게 됨.
    * 이것이 한끝차이지만 굉장히 큰 차이.
    * 함수 합성 관점에서의 Promise. 합성을 안전하게 해주는 Monad. 개발자가 의도하지 않은 상황(입력이 1개 예상했으나, 실제는 입력이 여러개 or 하나도 없음)일때, 에러를 안전하게 처리하기 위해 감싼 장치를 제공. 같은형의 객체를 반환(promise)하여 다음 연산(다음 체이닝)을 문제없이 실행할 수 있도록 함. 
      * f(g(x)) = f(g(x)) / f(g(x)) = g(x) 가 가능. promise로...
    * promise를 반환하면, 다음 행동을 다른 곳에 위임하여 제어할 수 있게 됨
  * 예제의 배열([1,2,3,4,5,..])을 수열이 아닌 할일 목록으로 사고하는 것. LISP. list로 일을 처리.
  * 함수형은 연산자를(ex. !) 쓰지 말고 메서드로 표현하는 것을 더 권장함. 이유는 연산자는 에러를 생기게 하기 쉽기 때문에.
  * 함수형으로 이루어진 코드. 엄청 안전함. 이 중에 하나도 스코프가 열린 곳이 없다. (외부상태에 의존하지 않고, 모두 독립적으로 동작)
    * 테스트코드 짤 필요가 없다 => ! 이 부분은 말하신 의도는 알겠으나 나는 비판적인 생각.
    * 추상화 수준을 동일하게 유지할 수 있게 됨
* 마지막으로 강의에서 함수형을 극찬하셨지만, 나는 이 와중에 `비판적 생각`도 몇 개 떠올랐으므로 정리해둠
  * 함수형으로 짠 엄청 큰 프로젝트가 있는데, 여기서 기본베이스가 되는 map, reduce, filter 이런 코드에서 고장나거나, 약간 내부가 변경된다거나 하면 모든 코드에게 영향을 주는데 이것이 정말 안전한게 맞는지에 대해 의문이 생겼다
  * 또 map, reduce, filter의 입력과 출력의 형태를 예제내내 우리가 같이 짜서 암묵적으로 공유하고 지키고 있기는 했지만, 이런 것들이 인수인계를 받는 사람 또는 새로 들어온 사람, 또는 프로젝트 전체 인원들이 계속 학습하고 잘 지켜나가야 하느 비용들이 있을텐데 이게 괜찮을지?도 모르겠고
  * 모나드 같은 장치가 오히려 디버깅을 어렵게 하지는 않을까? 하는 생각도 했음. 이 지점은 뭔가 방법이 분명 있어보이긴 한다.
  * 테스트코드를 짤 필요가 없다고 하셨는데 이땐 약간 너무 절대적인 의견처럼 느껴져서 반감!이ㅋ. 
    * 쨌든 추상화된 map, reduce, filter 들을 가져다 호출하는 측의 코드에서는 입력(도메인에 의존하는 입력)에 따라 여러가지 함수형명령을 거쳐 최종 결과물이 원하는 출력이 맞는지, 그니까 (제대로 저런 애들이 동작하냐를 의심하기보다) 함수의 조합들이 잘 꾸려져있는지를 테스트하는 코드는 필요하지 않을까 하는 생각을 했다. 



