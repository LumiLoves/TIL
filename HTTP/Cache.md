# Cache
프로젝트 배포 과정에서 캐시 관련 이슈가 생겼었는데, 매끄럽게 대응하기가 어려웠어서 이번 기회에 좀 더 자세히 알아보고자 공부하게 됨.  

---

**키워드 모아놓기**
* location.href = url vs location.replace(url)
* redirect
* 301 moved permanently
* .htaccess
* nuxt, useRedirectCookie
* 리소스 별 캐시정책 및 nginx 설정

**참고자료**
* [HTTP 캐싱-구글](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=ko)
* [Internet Explorer에서 캐싱을 방지하는 방법-마소](https://support.microsoft.com/ko-kr/help/234067/how-to-prevent-caching-in-internet-explorer)
* [HTTP caching-모질라](https://developer.mozilla.org/ko/docs/Web/HTTP/Caching)
* [캐시가 동작하는 아주 구체적인 원리](https://parksb.github.io/article/29.html)
* 책: HTTP 완벽가이드
* 코드: [Server Configs 샘플](https://github.com/h5bp/server-configs) // nginx 설정 참고해서 프로젝트 코드랑 비교해보기~
* [W3 - Cache-Control](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)

---
HTTP 책  
  
#
리다이렉션 상태코드 (300-399)
* 클라이언트 요청 리소스에 대해 => 다른 위치 사용하라고 알려주거나, 다른 대안 응답을 제공
* 리소스가 옮겨졌을 경우 / 301 (Moved Permanently)
  * 응답) Location: 'http://www......' 헤더를 선택적으로 보내줄 수 있음. 301일때 서버에서.
* 리소스에 대한 로컬복사본을 아직도 유효(서버에 있는 리소스와 같은지(최신인지), 다른지(수정되었는지))하게 사용해도 되는지 묻는 경우 / 304 (Not Modified)
  * 요청) If-Modified-Since: Fri, Oct ... 헤더 전송 / 00년 00월 이후에 수정된 문서일 경우만 가져와..!
  * 응답) 304 / 변경된거 없음! 응답코드만 내려줄테니 로컬복사본 사용해..!
 

#
캐시관련 헤더
* Cache-Control
  * no-store
  * no-cache
  * must-revalidate
  * max-age
* Pragma (하위호환성? 삭제될예정이라고?)
* Expires
* ETag
* 상태
  * cache hit : 대응하는 로컬사본 있음 / 사용 / 서버요청 X
  * cache miss : 대응하는 로컬사본 없음 / -  / 서버요청 O
  * cache revalidate : 대응하는 로컬사본 있음 / 서버에 신선도 검사 후, 사용 (신선도 검사에 대한 HTTP 규칙이 있다고 함) / If-Modified-Since 요청으로 서버에서 체크, 신선하면 304로 응답코드
    * 신선하지 않다면 (부적중), 평범한 200 으로 서버데이터를 보내줌
    * 서버객체가 삭제되었다면, 404 보내고, 로컬사본 삭제됨
  * 적중과 부적중의 구별
    * 두 경우 모두 응답코드는 200 (본문을 가지고 있다)
    * 이때 Date 헤더를 이용 => 응답의 Date 헤더값을 현재시각과 비교하여, 응답 생성일이 더 오래되었다면 캐시를 사용한 응답임을 알 수 있음.


----
구글개발자문서  
  
  
#
확인할 사항
* 각 서버 응답이 올바른 HTTP 헤더 지시문을 제공하여
* 브라우저가 응답을 캐시할 지점과 기간을 지시하는가

#
응답헤더로 캐시를 사용하는 방법
```
GET /file
200 OK
Content-Length: 1024
Cache-Control: max-age=120
ETag: "x234dff"
```
* 1024 바이트 응답을 반환 / 클라이언트에 최대 120초 동안 캐시하도록 지시 / 응답 만료후 리소스가 수정되었는지 확인하는데 사용할 수 있는 유효성검사 토큰('x234dff') 제공
* 120초가 지났고 + 동일한 리소스에 대해 새 요청을 실행하려 할 경우?
   * [요약해보장]: 로컬캐시 > 만료일 > ETag
      * (로컬캐시된) 이전 응답 찾기 -> 응답만료 체크 -> (만료 true?) -> 리소스 요청에 담긴 ETag로 유효성 검사 
      * -> (ETag 토큰값 같음!) -> 304, 캐시된 응답 재활용 + 만료시간 추가
      * -> (ETag 토큰값 다름?) -> 200, 새 응답 내림
   * 상세
     * 우선 브라우저는 로컬 캐시를 확인하고 이전 응답을 찾음
     * 응답이 만료되었음을 확인
     * 바로 전체 새 응답을 가져오지 않고, 만료된 캐시의 유효성 검사 (ETag 헤더의 토큰값(디지털 지문) 활용 / 재활용해서 쓸 수 있나?)를 함
        * 유효성 검사를 위해, 클라이언트가 요청헤더 내에 `If-None-Match: 'x234dff'` 라고 ETag의 토큰값을 자동으로 제공  `==> 그렇다면 기존 ETag값도 따로 저장하고 있다는 거넹?` 
        * 토큰이 변경되지 않은 경우: 서버에서 '304 Not Modified' 응답 반환 (리소스 변경 없으니 재활용해서 써랏, 유효기간도 120초 추가하구 / 응답을 다시 다운로드할 필요가 없으므로 시간과 대역폭이 절약됨)
        * 토큰이 변경된 경우: '200 OK' 내리면서 새 리소스 응답해줌
* 브라우저가 알아서 (자동으로) 토큰이 이전에 지정되었는지 탐지하고, 요청에 토큰을 추가해주고, 수신된 응답에 따라 필요하면 캐시 타임스탬프 업데이트까지 해줌
* 우리는 서버가 ETag 토큰을 제공하는지 확인하기만 하자~

# 
Cache-Control HTTP Header
* 각 리소스는 Cache-Control 헤더를 통해 캐싱정책을 정의
* 사용자, 해당조건, 기간 제어
* HTTP/1.1 사양 (이전 헤더(예: Expires)를 대체) `==> 앗! 그렇구만?!`
* 값종류
  * 'no-store'
    * 모든 응답을 저장할 수 없음. 요청할 때마다 전체 응답이 다운로드. => 가장 강력크?!
  * 'no-cache'
    * 최초에 로컬캐시 무시, 무조건 ETag로 유효성 체크후 캐시사용 가능 
  * 'public', 'private'
    * 'public'은 응답코드가 정상적으로 캐시할 수 없는 경우에도 캐시가능. 대부분의 경우 명시적 캐싱정보(예: 'max-age')가 응답이 어떤경우든 캐시가능하다고 나타내므로 'public'이 필요치 않음. / 브라우저캐시, 중간캐시 둘다 가능
    * 'private'는 브라우저가 캐시할 수 있음. 단일 사용자를 대상으로 하므로 중간캐시가 이 응답을 캐시하는 것은 허용되지 않음. 예: 비공개 사용자 정보가 포함된 HTML 페이지는 사용자의 브라우저가 캐시할 수 있지만, CDN은 이 페이지를 캐시할 수 없음 / 브라우저캐시만 가능
  * 'max-age'
    * 가져온 응답을 재활용할 수 있는 최대시간(초)

#
최적의 Cache-Control 정책 정의

* 주요 사이트 30만개에서 브라우저가 모든 응답의 절반을 캐시할 수 있다는 통계가 있다함.
* 사이트별 특성을 파악해, 캐시할 수 있는 리소스 파악후 적절한 Cache-Control, ETag를 설정
![Cache-Control 동작](https://camo.githubusercontent.com/75fca55d8a71f89a9bee513d38eaf853c3218dc1/68747470733a2f2f646576656c6f706572732e676f6f676c652e636f6d2f7765622f66756e64616d656e74616c732f706572666f726d616e63652f6f7074696d697a696e672d636f6e74656e742d656666696369656e63792f696d616765732f687474702d63616368652d6465636973696f6e2d747265652e706e67)

#
캐시된 응답 무효화 및 업데이트
* 로컬로 캐시된 응답은 리소스가 '만료'될 때까지 사용된다!!
* 파일명에 ETag 같은 키를 같이 넣으면, 새 응답을 업데이트하도록 강제가능
* 각 애플리케이션은 최적의 성능을 위해 **자체 캐시 계층구조를 정의**해야 함
  * 이미지 예시
    * HTML은 'no-cache': 매 요청마다 문서의 유효성 체크 및 최신버전 가져옴. CSS, JS URL에 유니크한 값을 포함했으므로 HTML의 콘텐츠 변경시 새 응답으로 받아오는 것이 가능.
    * CSS, JS는 유니크한 파일이름으로 업데이트 갱신을 할 수 있으므로, 만료기간을 넉넉히 (예제는 1년) 두어도 안전하게 동작됨.
    * JS는 private 설정. 아마도 CDN이 캐시하지 않아야 할 몇몇 비공개 사용자 데이터가 들어있을 수 있기 때문에 설정된 값일 것이다.
    * 이미지는 버전이나 유니크한 파일이름을 쓰지 않음. 같은 URL로 쓰이되, 캐시를 1일후 만료되도록 설정 `==> 이부분은 위험하지 않나?`
* ETag + Cache-Control + 고유 URL = 캐시를 고려한 최적화된 환경 구성
![리소스별 캐시설정](https://user-images.githubusercontent.com/23192677/55290593-0b75f300-5410-11e9-9111-5f58290c5b85.png)


#
캐싱 체크리스트
* 최고의 캐시정책은 없음 
  * -> 고려할 것들 : **트래픽 패턴 / 제공 데이터 유형 / 데이터 최신상태에 대한 애플리케이션 요구사항**
  * -> 이를 통해서 **적절한 리소스별 설정, 전체 캐싱 계층구조 정의**
* 체크리스트
  * 일관된 URL 사용: 동일한 컨텐츠는 동일한 URL로, URL은 대소문자 구분함
  * 서버가 ETag를 제공하는가? 
  * 중간캐시를 통해 캐시할 수 있는 리소스 식별 : 모든 사용자에게 동일한 응답을 갖는 리소스는 CDN 및 기타 중간캐시에 의해 캐시될 가능성이 큼
  * 각 리소스에 대해 최적의 캐시 수명 결정 : 리소스 URL과 유니크한 파일이름을 결합하여 사용 + **HTML 문서의 수명을 짧게 하거나 no-cache로 설정**
  * 이탈 최소화 : CSS나 JS 중에서도 자주 업데이트 되는 부분은 파일을 분리하여 제공하면 좋음. 다운로드 되는 콘텐츠 양이 최소화. `=> 대신 요청이 늘어날텐데.. 이런건 어떤 기준으로 결정하는게 좋을까? 다운로드 양 vs 요청 수` 



