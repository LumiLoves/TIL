# Cache
프로젝트 배포 과정에서 캐시 관련 이슈가 생겼었는데, 매끄럽게 대응하기가 어려웠어서 이번 기회에 좀 더 자세히 알아보고자 공부하게 됨.  

---

**키워드 모아놓기**
* location.href = url vs location.replace(url)
* redirect
* 301 moved permanently
* .htaccess
* nuxt, useRedirectCookie
* 리소스 별 캐시정책 및 nginx 설정

**참고자료**
* [HTTP 캐싱-구글](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=ko)
* [Internet Explorer에서 캐싱을 방지하는 방법-마소](https://support.microsoft.com/ko-kr/help/234067/how-to-prevent-caching-in-internet-explorer)
* [HTTP caching-모질라](https://developer.mozilla.org/ko/docs/Web/HTTP/Caching)
* [캐시가 동작하는 아주 구체적인 원리](https://parksb.github.io/article/29.html)
* 책: HTTP 완벽가이드
* 코드: [Server Configs 샘플](https://github.com/h5bp/server-configs) // nginx 설정 참고해서 프로젝트 코드랑 비교해보기~
* [W3 - Cache-Control](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)
* [레드봇](https://redbot.org) // 캐시와 관련된 HTTP 헤더 점검을 위한 

---
HTTP 책  
  
#
리다이렉션 상태코드 (300-399)
* 클라이언트 요청 리소스에 대해 => 다른 위치 사용하라고 알려주거나, 다른 대안 응답을 제공
* 리소스가 옮겨졌을 경우 / 301 (Moved Permanently)
  * 응답) Location: 'http://www......' 헤더를 선택적으로 보내줄 수 있음. 301일때 서버에서.
* 리소스에 대한 로컬복사본을 아직도 유효(서버에 있는 리소스와 같은지(최신인지), 다른지(수정되었는지))하게 사용해도 되는지 묻는 경우 / 304 (Not Modified)
  * 요청) If-Modified-Since: Fri, Oct ... 헤더 전송 / 00년 00월 이후에 수정된 문서일 경우만 가져와..!
  * 응답) 304 / 변경된거 없음! 응답코드만 내려줄테니 로컬복사본 사용해..!
 

#
캐시관련 헤더
* Cache-Control
  * no-store
  * no-cache
  * must-revalidate
  * max-age
* Pragma (하위호환성? 삭제될예정이라고?)
* Expires
* ETag
* 상태
  * cache hit : 대응하는 로컬사본 있음 / 사용 / 서버요청 X
  * cache miss : 대응하는 로컬사본 없음 / -  / 서버요청 O
  * cache revalidate : 대응하는 로컬사본 있음 / 서버에 신선도 검사 후, 사용 (신선도 검사에 대한 HTTP 규칙이 있다고 함) / If-Modified-Since 요청으로 서버에서 체크, 신선하면 304로 응답코드
    * 신선하지 않다면 (부적중), 평범한 200 으로 서버데이터를 보내줌
    * 서버객체가 삭제되었다면, 404 보내고, 로컬사본 삭제됨
  * 적중과 부적중의 구별
    * 두 경우 모두 응답코드는 200 (본문을 가지고 있다)
    * 이때 Date 헤더를 이용 => 응답의 Date 헤더값을 현재시각과 비교하여, 응답 생성일이 더 오래되었다면 캐시를 사용한 응답임을 알 수 있음.


----
구글개발자문서  
  
  
#
확인할 사항
* 각 서버 응답이 올바른 HTTP 헤더 지시문을 제공하여
* 브라우저가 응답을 캐시할 지점과 기간을 지시하는가

#
응답헤더로 캐시를 사용하는 방법
```
GET /file
200 OK
Content-Length: 1024
Cache-Control: max-age=120
ETag: "x234dff"
```
* 1024 바이트 응답을 반환 / 클라이언트에 최대 120초 동안 캐시하도록 지시 / 응답 만료후 리소스가 수정되었는지 확인하는데 사용할 수 있는 유효성검사 토큰('x234dff') 제공
* 120초가 지났고 + 동일한 리소스에 대해 새 요청을 실행하려 할 경우?
   * [요약해보장]: 로컬캐시 > 만료일 > ETag
      * (로컬캐시된) 이전 응답 찾기 -> 응답만료 체크 -> (만료 true?) -> 리소스 요청에 담긴 ETag로 유효성 검사 
      * -> (ETag 토큰값 같음!) -> 304, 캐시된 응답 재활용 + 만료시간 추가
      * -> (ETag 토큰값 다름?) -> 200, 새 응답 내림
   * 상세
     * 우선 브라우저는 로컬 캐시를 확인하고 이전 응답을 찾음
     * 응답이 만료되었음을 확인
     * 바로 전체 새 응답을 가져오지 않고, 만료된 캐시의 유효성 검사 (ETag 헤더의 토큰값(디지털 지문) 활용 / 재활용해서 쓸 수 있나?)를 함
        * 유효성 검사를 위해, 클라이언트가 요청헤더 내에 `If-None-Match: 'x234dff'` 라고 ETag의 토큰값을 자동으로 제공  `==> 그렇다면 기존 ETag값도 따로 저장하고 있다는 거넹?` 
        * 토큰이 변경되지 않은 경우: 서버에서 '304 Not Modified' 응답 반환 (리소스 변경 없으니 재활용해서 써랏, 유효기간도 120초 추가하구 / 응답을 다시 다운로드할 필요가 없으므로 시간과 대역폭이 절약됨)
        * 토큰이 변경된 경우: '200 OK' 내리면서 새 리소스 응답해줌
* 브라우저가 알아서 (자동으로) 토큰이 이전에 지정되었는지 탐지하고, 요청에 토큰을 추가해주고, 수신된 응답에 따라 필요하면 캐시 타임스탬프 업데이트까지 해줌
* 우리는 서버가 ETag 토큰을 제공하는지 확인하기만 하자~

# 
Cache-Control HTTP Header
* 각 리소스는 Cache-Control 헤더를 통해 캐싱정책을 정의
* 사용자, 해당조건, 기간 제어
* HTTP/1.1 사양 (이전 헤더(예: Expires)를 대체) `==> 앗! 그렇구만?!`
* 값종류
  * 'no-store'
    * 모든 응답을 저장할 수 없음. 요청할 때마다 전체 응답이 다운로드. => 가장 강력크?!
  * 'no-cache'
    * 최초에 로컬캐시 무시, 무조건 ETag로 유효성 체크후 캐시사용 가능 
  * 'public', 'private'
    * 'public'은 응답코드가 정상적으로 캐시할 수 없는 경우에도 캐시가능. 대부분의 경우 명시적 캐싱정보(예: 'max-age')가 응답이 어떤경우든 캐시가능하다고 나타내므로 'public'이 필요치 않음. / 브라우저캐시, 중간캐시 둘다 가능
    * 'private'는 브라우저가 캐시할 수 있음. 단일 사용자를 대상으로 하므로 중간캐시가 이 응답을 캐시하는 것은 허용되지 않음. 예: 비공개 사용자 정보가 포함된 HTML 페이지는 사용자의 브라우저가 캐시할 수 있지만, CDN은 이 페이지를 캐시할 수 없음 / 브라우저캐시만 가능
  * 'max-age'
    * 가져온 응답을 재활용할 수 있는 최대시간(초)

#
최적의 Cache-Control 정책 정의

* 주요 사이트 30만개에서 브라우저가 모든 응답의 절반을 캐시할 수 있다는 통계가 있다함.
* 사이트별 특성을 파악해, 캐시할 수 있는 리소스 파악후 적절한 Cache-Control, ETag를 설정
![Cache-Control 동작](https://camo.githubusercontent.com/75fca55d8a71f89a9bee513d38eaf853c3218dc1/68747470733a2f2f646576656c6f706572732e676f6f676c652e636f6d2f7765622f66756e64616d656e74616c732f706572666f726d616e63652f6f7074696d697a696e672d636f6e74656e742d656666696369656e63792f696d616765732f687474702d63616368652d6465636973696f6e2d747265652e706e67)

#
캐시된 응답 무효화 및 업데이트
* 로컬로 캐시된 응답은 리소스가 '만료'될 때까지 사용된다!!
* 파일명에 ETag 같은 키를 같이 넣으면, 새 응답을 업데이트하도록 강제가능
* 각 애플리케이션은 최적의 성능을 위해 **자체 캐시 계층구조를 정의**해야 함
  * 이미지 예시
    * HTML은 'no-cache': 매 요청마다 문서의 유효성 체크 및 최신버전 가져옴. CSS, JS URL에 유니크한 값을 포함했으므로 HTML의 콘텐츠 변경시 새 응답으로 받아오는 것이 가능.
    * CSS, JS는 유니크한 파일이름으로 업데이트 갱신을 할 수 있으므로, 만료기간을 넉넉히 (예제는 1년) 두어도 안전하게 동작됨.
    * JS는 private 설정. 아마도 CDN이 캐시하지 않아야 할 몇몇 비공개 사용자 데이터가 들어있을 수 있기 때문에 설정된 값일 것이다.
    * 이미지는 버전이나 유니크한 파일이름을 쓰지 않음. 같은 URL로 쓰이되, 캐시를 1일후 만료되도록 설정 `==> 이부분은 위험하지 않나?`
* ETag + Cache-Control + 고유 URL = 캐시를 고려한 최적화된 환경 구성
![리소스별 캐시설정](https://user-images.githubusercontent.com/23192677/55290593-0b75f300-5410-11e9-9111-5f58290c5b85.png)


#
캐싱 체크리스트
* 최고의 캐시정책은 없음 
  * -> 고려할 것들 : **트래픽 패턴 / 제공 데이터 유형 / 데이터 최신상태에 대한 애플리케이션 요구사항**
  * -> 이를 통해서 **적절한 리소스별 설정, 전체 캐싱 계층구조 정의**
* 체크리스트
  * 일관된 URL 사용: 동일한 컨텐츠는 동일한 URL로, URL은 대소문자 구분함
  * 서버가 ETag를 제공하는가? 
  * 중간캐시를 통해 캐시할 수 있는 리소스 식별 : 모든 사용자에게 동일한 응답을 갖는 리소스는 CDN 및 기타 중간캐시에 의해 캐시될 가능성이 큼
  * 각 리소스에 대해 최적의 캐시 수명 결정 : 리소스 URL과 유니크한 파일이름을 결합하여 사용 + **HTML 문서의 수명을 짧게 하거나 no-cache로 설정**
  * 이탈 최소화 : CSS나 JS 중에서도 자주 업데이트 되는 부분은 파일을 분리하여 제공하면 좋음. 다운로드 되는 콘텐츠 양이 최소화. `=> 대신 요청이 늘어날텐데.. 이런건 어떤 기준으로 결정하는게 좋을까? 다운로드 양 vs 요청 수` 



----
모질라. 
개발자문서 보면서 오타 수정 많이 해서 뿌듯.. / 모질라 캐시문서 볼 때마다 오타를 캐냄.. 오타 엄청 많넹. 기여고고

#
캐시
* 캐싱은 주어진 리소스의 복사본을 저장. 요청시에 그것을 서브하는 기술
* '웹캐시'가 자신의 저장소 내에 요청된 리소스를 가지고 있다면, 요청을 가로채 원래의 서버로부터 리소스를 다시 다운로드 하는 대신 리소스의 복사본을 반환
* 장점: 서버의 로드량 줄어듦 / 클라이언트 속도 향상 / 리소스 비용 다운
* 리소스는 영원히 변하지 않는 것이 아니므로 **캐시 자원을 변하기 전까지 유지하는 것**이 중요

#
여러 종류의 캐시들 (공유 캐시, 로컬 캐시)
* 사설 브라우저 캐시
  * 단일 사용자에게 초점. 
  * 브라우저 캐시는 사용자에 의하여 HTTP를 통해 다운로드된 모든 문서들을 가지고 있음.
  * (서버에 대한 추가적인 요청없이) **뒤로 가기나 앞으로 가기, 저장, 소스로 보기** 등을 위해 이용가능한 방문했던 문서들을 만드는데 사용
  * 캐시된 컨텐츠의 오프라인 브라우징 개선
* 공유 프록시 캐시
  * 한 명 이상의 사용자에 의해 재사용되는 응답을 저장하는 캐시
  * 예를 들어, 어떤 회사의 ISP는 많은 사용자들을 서브하기 위해 지역 네트워크 기반의 일부분으로써 웹 프록시를 설치해뒀을 수도 있는데, 그 덕분에 조회가 많이 되는 리소스들은 몇 번이고 재사용되어 네트워크 트래픽과 레이턴시를 줄여줌
* 그 외에도 더 나은 신뢰도, 성능 그리고 웹 사이트와 웹 애플리케이션의 확장을 위해 웹 서버 위에 배포되는 게이트웨이 캐시, CDN, 리버스 프록시 캐시 그리고 로드 밸랜서 등이 있음

#
캐싱 동작의 대상 ==> 캐시를 저장하는 기준이 되는 키
* 일반적인 HTTP GET Method 에 대한 응답을 캐싱하는 것으로 제한 / 다른 메서드들은 제외
* 1차 캐시 키는 '요청메서드 + 대상 URI'로 구성
* 일반적인 캐싱 엔트리 폼
  * 200 OK : 검색 요청의 성공적인 결과 
  * 301 : 영구적인 리다이렉트 (영구적으로 이동된 응답)
  * 404 : 오류 응답 (찾을 수 없음) 결과 페이지
  * 206 : 완전하지 않은 결과 (부분적인 컨텐츠 응답)
  * 캐시 키로 사용하기에 적절한 무언가가 정의된 경우의 GET 이외의 응답.
* 캐시 엔트리는 요청이 컨텐츠의 협상의 대상인 경우, 2번째 키에 의해 구별되는 다중저장응답으로 구성되어 있을 것.
(이 부분은 아무리 읽어도 모르겠다...)


#
캐싱 제어 : Cache-control 헤더와 Pragma 헤더
* Cache-control : ${값} (HTTP/1.1헤더)
  * no-store
    * 캐시 스토리지 전혀 없음
    * 캐시는 클라이언트 요청 혹은 서버 응답에 관해서 어떤 것도 저장해서는 안됨. 전체 응답은 매번 항상 다운로드됨
  * no-cache
    * 캐시하지 않음
    * 캐시된 복사본을 사용자에게 보여주기 전에, 재검증을 위해 원 서버로 요청을 보냄
  * private, public
    * (이쪽부분은 번역이 2sang해서 읽고 요약안함)
  * max-age=`<seconds>`
    * 리소스가 유효하다고 판단되는 최대시간
    * Expires와는 다르게, 이 디렉티브는 요청시간과 관련이 있음 ==> ?? 무슨말일까. 더찾아보기
  * must-revalidate
    * 캐시 사용전 유효한지 항상 체크
* Pragma (HTTP/1.0헤더)
  * Cache-Control는 HTTP/1.1이고, HTTP/1.0 클라이언트와의 하위호환성을 위한 경우에만 사용함
  
#
유효성 체크
* 캐시가 유효한지 확인하기 위해서 `If-None-Match`와 함께 요청으 전송. 유효하다면 서버는 요청된 리소스 본문을 전송하지 않고 304(수정되지않음) 헤더를 돌려보내, 대역폭을 절약함
* 클라이언트 - 캐시 - 서버
* 클라이언트가 요청을 보내면, 서버로 가기 전 캐시가 먼저 캐싱된 리소스 체크
![절차](https://mdn.mozillademos.org/files/13771/HTTPStaleness.png)
* 유효수명 계산
  1. "Cache-control: max-age=N" => 유효수명 = N
  2. 위 해더가 없다면? Expires 헤더 체크 => Expires헤더값 - Date 헤더값을 뺀 결과
  3. 위 헤더도 없다면? Last-Modified 헤더 체크 => (Date 헤더값 - Last-Modified헤더값) / 10
* 만료시간
  * `expirationTime = responseTime(브라우저가 수신한 시간) + freshnessLifetime - currentAge`


#
활성화된(Revved) 리소스
* 캐시된 리소스를 사용하면 할수록 웹사이트의 응답성과 성능은 점점 더 좋아질 것. 
* 이것을 최적화 하기 위한 실제방법은 만료시간을 가능한 더 먼 미래로 설정하는 것.
* 이것은 리소스를 자주 갱신함으로써 가능하지만, 아주 드물 업데이트되는 리소스의 경우에는 문제가 됨.
* 이런 리소스들은 캐시한 리소스로부터 최대한 활용되는 리소스들 / 캐시를 사용하다가도 원할때 빠르게 변경되야 함.
* 이런 것을 해결하기 위해 웹개발자들이 Revving이라는 기술을 발명!
![Revved방법](https://mdn.mozillademos.org/files/13779/HTTPRevved.png)



















